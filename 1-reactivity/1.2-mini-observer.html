<script>
/**
GOAL:
Implement two functions, observe() and autorun().

- autorun() takes an update function and re-runs it when properties that the
  update function subscribes to have been mutated. An update function is said
  to be "subscribing" to a property if it relies on that property during its
  evaluation.

- observe() converts the properties in the received object and make them
  reactive. For each converted property, it keeps track of a list of subscribing
  update functions, and triggers them to re-run when its setter is invoked.

- They should support the following usage:

```
const state = {
  count: 0
}

observe(state)

autorun(() => {
  console.log(state.count)
})
// should immediately log "count is: 0"

state.count++
// should log "count is: 1"
```

To test if your implementation is correct, run:

  npm test -- -t 1.2

*/

// This is an greatly simplified version of the dependency tracking
// system used in Vue, Knockout, MobX and Meteor Tracker (each with different
// implementation details, of course). It doesn't cover all the possible edge
// cases in detection, nor does it handle Arrays; The goal is simply to better
// understand how the tracking takes place and how data becomes "reactive".

let activeUpdate = null

function observe (obj) {
  // iterate through all properties on the object
  // and convert them into getter/setters with
  // Object.defineProperty()
  Object.keys(obj).forEach(key => {
    let internalValue = obj[key]
    const subscribers = new Set()

    Object.defineProperty(obj, key, {
      // The getter is responsible for "registering" a
      // computation that relies on this object
      get () {
        if (activeUpdate) {
          subscribers.add(activeUpdate)
        }
        return internalValue
      },

      // The setter is responsible for triggering all
      // registered computation to execute again
      set (newVal) {
        const changed = internalValue !== newVal
        internalValue = newVal
        // triggering re-computation
        if (changed) {
          subscribers.forEach(update => update())
        }
      }
    })
  })
  return obj
}

function autorun (update) {
  // wrap the raw update function into a "job" function that registers and
  // unregisters itself as the current active job when invoked
  const wrappedUpdate = () => {
    activeUpdate = wrappedUpdate
    update()
    activeUpdate = null
  }
  wrappedUpdate()
}
</script>
